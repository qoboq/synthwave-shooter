<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synthwave Hologram UI - Multiplayer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050011;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        /* CRT Scanline Effect Overlay */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Vignette */
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 11;
        }

        /* Damage Flash Overlay */
        #damage-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: red;
            opacity: 0;
            pointer-events: none;
            z-index: 15;
            transition: opacity 0.1s;
        }

        /* HUD Layer */
        #hud-layer {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            height: 100px;
            pointer-events: none;
            z-index: 25;
            display: flex;
            justify-content: space-between;
            padding: 0 50px;
            box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
            text-shadow: 0 0 5px currentColor;
        }

        /* Health Section */
        #health-container {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            width: 300px;
            color: #00ff00;
            transition: color 0.3s;
        }
        #health-label {
            font-size: 20px;
            margin-bottom: 8px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }
        #health-bar-frame {
            width: 100%;
            height: 24px;
            border: 2px solid currentColor;
            padding: 3px;
            background: rgba(0, 20, 0, 0.5);
            box-shadow: 0 0 10px currentColor;
            transform: skewX(-20deg);
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background-color: currentColor;
            transition: width 0.2s;
            box-shadow: 0 0 10px currentColor;
        }

        /* Ammo Section */
        #ammo-container {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: flex-end;
            color: #00ffff;
            width: 250px;
        }
        #ammo-val {
            font-size: 72px;
            font-weight: bold;
            line-height: 0.8;
        }
        #ammo-label {
            font-size: 18px;
            letter-spacing: 2px;
            margin-top: 10px;
            text-align: right;
        }
        
        /* Score/Multiplayer Info Section */
        #score-container {
            position: absolute;
            top: 30px;
            right: 50px;
            text-align: right;
            color: #ff00ff;
            z-index: 25;
            pointer-events: none;
        }
        #score-val {
            font-size: 48px;
            font-weight: bold;
        }
        #score-label {
            font-size: 16px;
            letter-spacing: 1px;
        }
        #online-count {
            font-size: 14px;
            color: #00ff00;
            margin-top: 5px;
        }
        
        /* Reloading Animation */
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.2; } 100% { opacity: 1; } }
        .reloading {
            color: #ff0055 !important;
            animation: blink 0.5s infinite;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffff;
            z-index: 20;
            text-shadow: 0 0 10px #00ffff;
            opacity: 0.8;
            pointer-events: none; 
        }

        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid #00ffff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            pointer-events: none;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #ff0055;
            transform: translate(-50%, -50%);
        }

        /* Instructions Overlay */
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            z-index: 30;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ffff;
            text-align: center;
        }
        #instructions {
            font-size: 24px;
            cursor: pointer;
        }
        
        #game-over {
            display: none;
            color: #ff0000;
            font-size: 60px;
            font-weight: bold;
            text-shadow: 0 0 20px #ff0000;
        }
        #respawn-timer {
            font-size: 20px;
            color: white;
            display: none;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="scanlines"></div>
    <div id="vignette"></div>
    <div id="damage-overlay"></div>
    <div id="crosshair"></div>
    
    <div id="score-container">
        <div id="score-val">0</div>
        <div id="score-label">SCORE</div>
        <div id="online-count">ONLINE: 1</div>
    </div>

    <div id="hud-layer">
        <div id="health-container">
            <div id="health-label">
                <span>SUIT INTEGRITY</span>
                <span id="hp-text">100%</span>
            </div>
            <div id="health-bar-frame">
                <div id="health-bar"></div>
            </div>
        </div>
        <div id="ammo-container">
            <div id="ammo-val">20</div>
            <div id="ammo-label">PLASMA CHARGE</div>
        </div>
    </div>
    
    <div id="blocker">
        <div id="instructions">
            <p style="font-size: 40px;">CLICK TO CONNECT</p>
            <p>Move: W, A, S, D</p>
            <p>Look: Mouse</p>
            <p>Fire: Click</p>
        </div>
        <div id="game-over">
            CRITICAL FAILURE<br>
            <div id="respawn-timer">Respawning in 3...</div>
        </div>
    </div>

    <div id="ui-layer">
        <h3>SYSTEM: MULTIPLAYER ONLINE</h3>
        <p>WEAPON: PLASMA_RAIL_V2</p>
        <p>TARGET: DRONES & PLAYERS</p>
        <p id="status-log" style="font-size: 0.8em; opacity: 0.7;">> ESTABLISHING LINK...</p>
    </div>

    <!-- Import Three.js and Addons as Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        // --- FIREBASE SETUP ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, updateDoc, increment, getDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        let currentUser = null;
        let myPlayerId = null;
        let myColor = Math.random() * 0xffffff;
        
        // --- CONFIGURATION ---
        const COLORS = {
            neonPink: 0xff00ff,
            neonCyan: 0x00ffff,
            deepPurple: 0x2d0045,
            gridColor: 0x9c27b0,
            laserColor: 0xff0055,
            enemyLaserColor: 0x00ff00, 
            healthFull: 0x00ff00,
            healthLow: 0xff0000,
            gunBody: 0x1a1a1a,
            gunGlow: 0x00ffff
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050011, 0.025);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 12); 
        scene.add(camera);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- FPS CONTROLS ---
        const controls = new PointerLockControls(camera, document.body);
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const gameOverText = document.getElementById('game-over');
        const respawnTimer = document.getElementById('respawn-timer');
        const damageOverlay = document.getElementById('damage-overlay');
        
        // HUD ELEMENTS
        const healthBar = document.getElementById('health-bar');
        const healthContainer = document.getElementById('health-container');
        const hpText = document.getElementById('hp-text');
        const ammoVal = document.getElementById('ammo-val');
        const ammoLabel = document.getElementById('ammo-label');
        const scoreVal = document.getElementById('score-val');
        const onlineCount = document.getElementById('online-count');

        instructions.addEventListener('click', function () {
            controls.lock();
        });
        controls.addEventListener('lock', function () {
            instructions.style.display = 'none';
            blocker.style.display = 'none';
        });
        controls.addEventListener('unlock', function () {
            blocker.style.display = 'flex';
            if(!isPlayerDead) instructions.style.display = '';
        });

        // Input
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        const onKeyDown = (event) => {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
            }
        };
        const onKeyUp = (event) => {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        };
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // --- POST PROCESSING ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 2.0;
        bloomPass.radius = 0.5;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- GAME STATE ---
        let playerHealth = 100;
        let score = 0;
        let isPlayerDead = false;
        let currentAmmo = 20;
        const maxAmmo = 20;
        let isReloading = false;

        // Entities
        const enemies = []; // Local AI
        const maxEnemies = 3;
        const otherPlayers = {}; // Networked Players { id: mesh }
        const lasers = []; 
        const enemyLasers = []; 
        const explosionParticles = [];
        
        // Gun
        let gunGroup;
        let muzzlePoint;
        let recoilOffset = 0;
        const raycaster = new THREE.Raycaster();
        let intersectedObject = null;

        // --- FIREBASE LOGIC ---

        async function initAuth() {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
            currentUser = auth.currentUser;
            if (currentUser) {
                myPlayerId = currentUser.uid;
                document.getElementById('status-log').innerText = "> ONLINE ID: " + myPlayerId.substring(0, 5);
                startMultiplayer();
            }
        }
        initAuth();

        function startMultiplayer() {
            // 1. Listen for other players
            const playersRef = collection(db, 'artifacts', appId, 'public', 'data', 'players');
            
            onSnapshot(playersRef, (snapshot) => {
                const activeIds = new Set();
                
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    const pid = doc.id;
                    activeIds.add(pid);

                    // Update local player health from DB (Source of Truth for PvP)
                    if (pid === myPlayerId) {
                        if (data.health !== undefined && data.health < playerHealth) {
                             // We took damage from someone else
                             takePlayerDamage(playerHealth - data.health); 
                        }
                        // Sync local health state to DB if we respawned locally but DB is old? 
                        // No, simpler: DB is updated by shooters. We just react.
                        // But if we respawn, we must write 100 to DB.
                        return; 
                    }

                    // Handle Other Players
                    if (!otherPlayers[pid]) {
                        // New player joined
                        otherPlayers[pid] = createOtherPlayerMesh(data.color);
                    }

                    // Update Position
                    const mesh = otherPlayers[pid];
                    if(mesh) {
                        // Interpolation could go here, for now direct set
                        mesh.position.set(data.x, data.y, data.z);
                        mesh.rotation.y = data.ry;
                        
                        // Visual damage check
                        if (data.health <= 0) {
                            if (mesh.visible) {
                                spawnExplosion(mesh.position, 50, data.color);
                                mesh.visible = false;
                            }
                        } else {
                            mesh.visible = true;
                        }
                    }
                });

                // Remove disconnected players
                Object.keys(otherPlayers).forEach(pid => {
                    if (!activeIds.has(pid)) {
                        spawnExplosion(otherPlayers[pid].position, 20, 0xaaaaaa);
                        scene.remove(otherPlayers[pid]);
                        delete otherPlayers[pid];
                    }
                });
                
                onlineCount.innerText = "ONLINE: " + activeIds.size;
            }, (error) => {
                 console.error("Error getting players:", error);
            });

            // 2. Start Update Loop
            setInterval(sendMyUpdate, 80); // ~12 times a second
            
            // 3. Start Cleanup Loop (remove stale players from DB)
            setInterval(cleanupStalePlayers, 5000);
            
            // 4. Initialize my entry
            updateMyDoc(100);
        }

        async function updateMyDoc(hp) {
            if (!myPlayerId) return;
            const myRef = doc(db, 'artifacts', appId, 'public', 'data', 'players', myPlayerId);
            await setDoc(myRef, {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z,
                ry: camera.rotation.y, // Approximate facing
                color: myColor,
                health: hp !== undefined ? hp : playerHealth,
                lastSeen: Date.now()
            }, { merge: true });
        }

        function sendMyUpdate() {
            if(!myPlayerId || isPlayerDead) return;
            // Fire and forget update
            updateMyDoc(); 
        }

        async function cleanupStalePlayers() {
             // In a real backend this runs on server. Here, maybe the "host" does it?
             // For this simple demo, we won't delete others to avoid race conditions, 
             // but the client filters them out visually if needed or we rely on them sending 'lastSeen'.
             // We will just delete OURSELVES on unload.
        }

        window.addEventListener('beforeunload', () => {
            if(myPlayerId) {
                const myRef = doc(db, 'artifacts', appId, 'public', 'data', 'players', myPlayerId);
                deleteDoc(myRef);
            }
        });

        // --- OBJECT CREATION ---

        function createOtherPlayerMesh(color) {
            const group = new THREE.Group();
            
            // Simple Drone Representation for other players
            const bodyGeo = new THREE.ConeGeometry(0.4, 1, 4);
            bodyGeo.rotateX(Math.PI / 2); // Point forward
            const bodyMat = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            group.add(body);
            
            // Floating Name/Health (Simulated)
            const ringGeo = new THREE.TorusGeometry(0.6, 0.02, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            group.add(ring);

            // Store logic for raycasting
            // Add a hit box
            const hitGeo = new THREE.BoxGeometry(1, 1.5, 1);
            const hitMat = new THREE.MeshBasicMaterial({ visible: false });
            const hitBox = new THREE.Mesh(hitGeo, hitMat);
            hitBox.userData = { isPlayer: true }; 
            group.add(hitBox);

            scene.add(group);
            return group;
        }

        // Gun Building
        function buildGun() {
            const gun = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: COLORS.gunBody, roughness: 0.4, metalness: 0.8 });
            const glowMat = new THREE.MeshBasicMaterial({ color: COLORS.gunGlow });
            gun.add(new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.6), bodyMat)); 
            const rail = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.05, 0.5), bodyMat); 
            rail.position.set(0, 0.13, 0);
            gun.add(rail);
            const strip = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.02, 0.4), glowMat); 
            strip.position.set(0, 0.05, 0);
            gun.add(strip);
            const barrelGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 16);
            barrelGeo.rotateX(-Math.PI / 2); 
            const barrel = new THREE.Mesh(barrelGeo, new THREE.MeshStandardMaterial({color: 0x333333}));
            barrel.position.set(0, 0.05, -0.2);
            gun.add(barrel);
            muzzlePoint = new THREE.Object3D();
            muzzlePoint.position.set(0, 0.05, -0.6);
            gun.add(muzzlePoint);
            gun.position.set(0.3, -0.25, -0.6);
            return gun;
        }
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const camLight = new THREE.DirectionalLight(0xffffff, 1);
        camLight.position.set(1, 2, 0);
        camera.add(camLight); 
        gunGroup = buildGun();
        camera.add(gunGroup);

        // Grid
        const gridGeometry = new THREE.PlaneGeometry(120, 120, 60, 60);
        const gridMaterial = new THREE.MeshBasicMaterial({ color: COLORS.gridColor, wireframe: true, transparent: true, opacity: 0.3 });
        const grid = new THREE.Mesh(gridGeometry, gridMaterial);
        grid.rotation.x = -Math.PI / 2;
        grid.position.y = -2;
        scene.add(grid);

        // --- ENTITY LOGIC ---

        function createEnemy(startPos) {
            const group = new THREE.Group();
            group.position.copy(startPos);
            
            const coreGeo = new THREE.IcosahedronGeometry(1, 1);
            const coreMat = new THREE.MeshBasicMaterial({ color: COLORS.neonCyan, wireframe: true, transparent: true, opacity: 0.8 });
            const core = new THREE.Mesh(coreGeo, coreMat);
            group.add(core);
            const nucGeo = new THREE.IcosahedronGeometry(0.4, 2);
            const nucMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const nucleus = new THREE.Mesh(nucGeo, nucMat);
            group.add(nucleus);
            const hpGroup = new THREE.Group();
            hpGroup.position.y = 1.8;
            group.add(hpGroup); 
            hpGroup.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 0.15), new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide })));
            const hpFillGeo = new THREE.PlaneGeometry(2, 0.15);
            hpFillGeo.translate(1, 0, 0);
            const hpFill = new THREE.Mesh(hpFillGeo, new THREE.MeshBasicMaterial({ color: COLORS.healthFull, side: THREE.DoubleSide }));
            hpFill.position.x = -1; 
            hpGroup.add(hpFill);
            const ringGroup = new THREE.Group();
            const ring1 = new THREE.Mesh(new THREE.TorusGeometry(1.8, 0.02, 16, 100), new THREE.MeshBasicMaterial({ color: COLORS.neonPink }));
            ring1.rotation.x = Math.PI / 2;
            ringGroup.add(ring1);
            const ring2 = new THREE.Mesh(new THREE.TorusGeometry(2.2, 0.02, 16, 100), new THREE.MeshBasicMaterial({ color: COLORS.neonCyan }));
            ring2.rotation.x = Math.PI / 2.2;
            ringGroup.add(ring2);
            group.add(ringGroup);
            scene.add(group);

            return {
                group: group,
                core: core,
                nucleus: nucleus,
                hpFill: hpFill,
                hpGroup: hpGroup,
                rings: ringGroup,
                health: 100,
                maxHealth: 100,
                lastFireTime: 0,
                fireRate: 2.0 + Math.random() * 1.5,
                movementPhase: Math.random() * 100
            };
        }

        function spawnEnemy() {
            if (enemies.length >= maxEnemies) return;
            const angle = Math.random() * Math.PI * 2;
            const dist = 10 + Math.random() * 10;
            const pos = new THREE.Vector3(Math.cos(angle) * dist, Math.random() * 3 - 1, Math.sin(angle) * dist);
            const enemy = createEnemy(pos);
            enemy.group.scale.set(0.1, 0.1, 0.1);
            let warpIn = setInterval(() => {
                if(!enemy.group) { clearInterval(warpIn); return; }
                enemy.group.scale.multiplyScalar(1.1);
                if(enemy.group.scale.x >= 1) {
                    enemy.group.scale.set(1,1,1);
                    clearInterval(warpIn);
                }
            }, 30);
            enemies.push(enemy);
        }

        for(let i=0; i<maxEnemies; i++) spawnEnemy();

        // Panels (Local)
        const panels = [];
        function createPanel(x, y, z, text, subtext, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = color; ctx.lineWidth = 4; ctx.strokeRect(10, 10, 492, 236);
            ctx.font = 'bold 60px Courier New'; ctx.fillStyle = color; ctx.textAlign = 'center'; ctx.fillText(text, 256, 100);
            if (subtext) { ctx.font = '30px Courier New'; ctx.fillText(subtext, 256, 160); }
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; for(let i=0; i<canvas.height; i+=4) ctx.fillRect(0, i, canvas.width, 1);
            const tex = new THREE.CanvasTexture(canvas);
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 1), new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.9, side: THREE.DoubleSide, blending: THREE.AdditiveBlending, color: 0xffffff }));
            mesh.position.set(x, y, z); mesh.lookAt(0, 0, 0); mesh.userData = { isPanel: true, originalColor: 0xffffff };
            scene.add(mesh); panels.push(mesh); return mesh;
        }
        createPanel(-3.5, 1, 0, "ANALYSIS", "Sector 7G", "#00ffff");
        createPanel(3.5, 1, 0, "DATABASE", "Encrypted", "#ff00ff");
        createPanel(0, 2.5, -1, "WARNING", "High Voltage", "#ff3333");

        // Particles
        const particlesGeo = new THREE.BufferGeometry();
        const particleCount = 500;
        const posArray = new Float32Array(particleCount * 3);
        for(let i = 0; i < particleCount * 3; i++) posArray[i] = (Math.random() - 0.5) * 20;
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particles = new THREE.Points(particlesGeo, new THREE.PointsMaterial({ size: 0.03, color: COLORS.neonPink, transparent: true, opacity: 0.6 }));
        scene.add(particles);

        // --- GAMEPLAY LOGIC ---

        function spawnExplosion(position, count, color) {
            const geo = new THREE.BufferGeometry();
            const pos = []; const vels = [];
            for(let i=0; i<count; i++) {
                pos.push(position.x, position.y, position.z);
                vels.push((Math.random()-0.5)*1.5, (Math.random()-0.5)*1.5, (Math.random()-0.5)*1.5);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const points = new THREE.Points(geo, new THREE.PointsMaterial({ color: color, size: 0.15, transparent: true, blending: THREE.AdditiveBlending }));
            points.userData = { velocities: vels, life: 1.0 };
            scene.add(points);
            explosionParticles.push(points);
        }

        function updateAmmoUI() { ammoVal.innerText = currentAmmo; }
        function reloadWeapon() {
            if(isReloading) return;
            isReloading = true;
            ammoLabel.innerText = "RECHARGING...";
            ammoVal.classList.add('reloading');
            ammoLabel.classList.add('reloading');
            ammoVal.style.color = "#ff0055"; ammoLabel.style.color = "#ff0055";
            setTimeout(() => {
                currentAmmo = maxAmmo; isReloading = false; updateAmmoUI();
                ammoLabel.innerText = "PLASMA CHARGE";
                ammoVal.classList.remove('reloading'); ammoLabel.classList.remove('reloading');
                ammoVal.style.color = "#00ffff"; ammoLabel.style.color = "#00ffff";
            }, 2000);
        }

        async function damageOtherPlayer(targetId) {
            if (!myPlayerId) return;
            const targetRef = doc(db, 'artifacts', appId, 'public', 'data', 'players', targetId);
            // Atomic decrement
            await updateDoc(targetRef, { health: increment(-10) });
        }

        function playerFire() {
            if(isPlayerDead || isReloading) return;
            if (currentAmmo <= 0) { reloadWeapon(); return; }
            currentAmmo--; updateAmmoUI();
            if(currentAmmo === 0) reloadWeapon();

            recoilOffset = 0.15;
            const laser = new THREE.Mesh(new THREE.CapsuleGeometry(0.05, 1.5, 4, 8), new THREE.MeshBasicMaterial({ color: COLORS.laserColor }));
            const startPos = new THREE.Vector3();
            muzzlePoint.getWorldPosition(startPos);
            laser.position.copy(startPos);
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera); 
            const direction = raycaster.ray.direction.clone();
            laser.lookAt(startPos.clone().add(direction));
            laser.rotateX(Math.PI / 2); 
            laser.userData = { velocity: direction.multiplyScalar(1.2), life: 100 };
            scene.add(laser);
            lasers.push(laser);
        }

        function aiFire(enemy) {
            if(isPlayerDead) return;
            const laser = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 2, 4, 8), new THREE.MeshBasicMaterial({ color: COLORS.enemyLaserColor }));
            laser.position.copy(enemy.group.position);
            const direction = new THREE.Vector3().subVectors(camera.position, enemy.group.position).normalize();
            direction.x += (Math.random() - 0.5) * 0.05; direction.y += (Math.random() - 0.5) * 0.05; direction.z += (Math.random() - 0.5) * 0.05;
            laser.lookAt(camera.position); laser.rotateX(Math.PI / 2);
            laser.userData = { velocity: direction.multiplyScalar(0.6), life: 200 };
            scene.add(laser);
            enemyLasers.push(laser);
        }

        function takePlayerDamage(damage = 10) {
            if(isPlayerDead) return;
            playerHealth -= damage;
            const pct = Math.max(0, playerHealth);
            healthBar.style.width = pct + '%';
            hpText.innerText = pct + '%';
            if (playerHealth <= 30) healthContainer.style.color = '#ff0000';
            damageOverlay.style.opacity = 0.6;
            setTimeout(() => { damageOverlay.style.opacity = 0; }, 100);

            // We update DB health in real time? 
            // Actually, we should sync health.
            updateMyDoc(playerHealth);

            if(playerHealth <= 0) {
                die();
            }
        }

        function die() {
            isPlayerDead = true;
            controls.unlock();
            instructions.style.display = 'none';
            gameOverText.style.display = 'block';
            respawnTimer.style.display = 'block';
            healthBar.style.width = '0%';
            
            // Start respawn timer
            let countdown = 3;
            respawnTimer.innerText = `Respawning in ${countdown}...`;
            const timerInterval = setInterval(() => {
                countdown--;
                respawnTimer.innerText = `Respawning in ${countdown}...`;
                if(countdown <= 0) {
                    clearInterval(timerInterval);
                    respawn();
                }
            }, 1000);
        }

        function respawn() {
            isPlayerDead = false;
            playerHealth = 100;
            updateMyDoc(100); // Reset in DB
            
            // Reset UI
            healthBar.style.width = '100%';
            hpText.innerText = '100%';
            healthContainer.style.color = '#00ff00';
            gameOverText.style.display = 'none';
            respawnTimer.style.display = 'none';
            instructions.style.display = '';
            controls.lock();
            
            // Random position
            const angle = Math.random() * Math.PI * 2;
            camera.position.set(Math.cos(angle)*10, 1.6, Math.sin(angle)*10);
            camera.lookAt(0,0,0);
        }

        // --- INPUT ---
        window.addEventListener('mousedown', (event) => {
            if (!controls.isLocked) return;
            if (intersectedObject && intersectedObject.userData.isPanel) {
                // UI Interaction logic
                const originalColor = intersectedObject.userData.originalColor;
                intersectedObject.material.color.setHex(0xffffff);
                setTimeout(() => { if(intersectedObject) intersectedObject.material.color.setHex(originalColor); }, 150);
                return; 
            }
            playerFire();
        });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- ANIMATION ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            if (controls.isLocked && !isPlayerDead) {
                velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta;
                direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft); direction.normalize();
                if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * delta;
                controls.moveRight(-velocity.x * delta); controls.moveForward(-velocity.z * delta);
            }

            // Update Entities
            enemies.forEach((enemy) => {
                const phase = elapsedTime + enemy.movementPhase;
                enemy.group.position.y = Math.sin(phase * 0.5) * 1.5;
                enemy.group.rotation.y = Math.sin(phase * 0.2) * 0.2;
                enemy.group.lookAt(camera.position);
                enemy.core.rotation.x += 0.01; enemy.core.rotation.y += 0.02; enemy.rings.rotation.z -= 0.01; enemy.hpGroup.lookAt(camera.position);
                if (elapsedTime - enemy.lastFireTime > enemy.fireRate) { aiFire(enemy); enemy.lastFireTime = elapsedTime; }
            });

            // Raycaster (UI)
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(panels);
            if (intersects.length > 0) {
                if (intersectedObject != intersects[0].object) {
                    if (intersectedObject) intersectedObject.scale.set(1, 1, 1);
                    intersectedObject = intersects[0].object; intersectedObject.scale.set(1.1, 1.1, 1.1);
                }
                document.getElementById('crosshair').style.borderColor = '#ff00ff';
            } else {
                if (intersectedObject) { intersectedObject.scale.set(1, 1, 1); intersectedObject = null; }
                document.getElementById('crosshair').style.borderColor = '#00ffff';
            }

            gunGroup.position.z = THREE.MathUtils.lerp(gunGroup.position.z, -0.6 + recoilOffset, 0.2);
            recoilOffset = THREE.MathUtils.lerp(recoilOffset, 0, 0.1);

            // LASERS
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                laser.position.add(laser.userData.velocity);
                laser.userData.life--;
                let laserRemoved = false;

                // 1. Collision with Local Enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (laser.position.distanceTo(enemy.group.position) < 2.0) {
                        scene.remove(laser); lasers.splice(i, 1); laserRemoved = true;
                        enemy.health -= 10;
                        spawnExplosion(laser.position, 5, 0xffaa00);
                        enemy.core.material.color.setHex(0xff0000);
                        setTimeout(() => { if(enemy.core) enemy.core.material.color.setHex(COLORS.neonCyan); }, 50);
                        const pct = Math.max(0, enemy.health / enemy.maxHealth);
                        enemy.hpFill.scale.x = pct;
                        if(pct < 0.3) enemy.hpFill.material.color.setHex(COLORS.healthLow);
                        if (enemy.health <= 0) {
                            spawnExplosion(enemy.group.position, 80, COLORS.neonCyan);
                            scene.remove(enemy.group); enemies.splice(j, 1);
                            score += 100; scoreVal.innerText = score;
                            setTimeout(spawnEnemy, 3000);
                        }
                        break;
                    }
                }

                // 2. Collision with Other Players (PvP)
                if (!laserRemoved) {
                     const playerIds = Object.keys(otherPlayers);
                     for(let k=0; k < playerIds.length; k++) {
                         const pid = playerIds[k];
                         const meshGroup = otherPlayers[pid];
                         // Simple box check
                         if (meshGroup.visible && laser.position.distanceTo(meshGroup.position) < 2.0) {
                             scene.remove(laser); lasers.splice(i, 1); laserRemoved = true;
                             spawnExplosion(laser.position, 10, 0xff0000); // Hit effect
                             damageOtherPlayer(pid); // Update DB
                             break;
                         }
                     }
                }

                if (!laserRemoved && laser.userData.life <= 0) { scene.remove(laser); lasers.splice(i, 1); }
            }

            for (let i = enemyLasers.length - 1; i >= 0; i--) {
                const laser = enemyLasers[i];
                laser.position.add(laser.userData.velocity);
                laser.userData.life--;
                if (laser.position.distanceTo(camera.position) < 1.0) {
                    scene.remove(laser); enemyLasers.splice(i, 1);
                    takePlayerDamage();
                    continue;
                }
                if (laser.userData.life <= 0) { scene.remove(laser); enemyLasers.splice(i, 1); }
            }

            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const sys = explosionParticles[i];
                const positions = sys.geometry.attributes.position.array;
                const velocities = sys.userData.velocities;
                for(let j=0; j < positions.length / 3; j++) {
                    positions[j*3] += velocities[j*3];
                    positions[j*3+1] += velocities[j*3+1];
                    positions[j*3+2] += velocities[j*3+2];
                }
                sys.geometry.attributes.position.needsUpdate = true;
                sys.userData.life -= 0.02; sys.material.opacity = sys.userData.life;
                if(sys.userData.life <= 0) { scene.remove(sys); explosionParticles.splice(i, 1); }
            }

            grid.position.x = Math.floor(camera.position.x / 10) * 10;
            grid.position.z = Math.floor(camera.position.z / 10) * 10 - 2;
            particles.rotation.y = elapsedTime * 0.05;

            panels.forEach((panel, index) => {
                if(panel !== intersectedObject) panel.position.y += Math.sin(elapsedTime + index) * 0.002;
            });

            composer.render();
        }
        animate();
    </script>
</body>
</html>